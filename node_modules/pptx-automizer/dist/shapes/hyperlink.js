"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hyperlink = void 0;
const xml_helper_1 = require("../helper/xml-helper");
const shape_1 = require("../classes/shape");
const content_tracker_1 = require("../helper/content-tracker");
class Hyperlink extends shape_1.Shape {
    constructor(shape, targetType, sourceArchive, hyperlinkType = 'external', hyperlinkTarget = '') {
        super(shape, targetType);
        this.sourceArchive = sourceArchive;
        this.hyperlinkType = hyperlinkType;
        this.hyperlinkTarget = hyperlinkTarget;
        this.relRootTag = 'a:hlinkClick';
        this.relAttribute = 'r:id';
    }
    modify(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare(targetTemplate, targetSlideNumber);
            yield this.editTargetHyperlinkRel();
            yield this.updateHyperlinkInSlide();
            return this;
        });
    }
    append(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare(targetTemplate, targetSlideNumber);
            yield this.setTargetElement();
            yield this.appendToSlideTree();
            yield this.editTargetHyperlinkRel();
            yield this.updateHyperlinkInSlide();
            return this;
        });
    }
    remove(targetTemplate, targetSlideNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare(targetTemplate, targetSlideNumber);
            yield this.removeFromSlideRels();
            return this;
        });
    }
    prepare(targetTemplate, targetSlideNumber, hyperlinks) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setTarget(targetTemplate, targetSlideNumber);
            if (!this.createdRid) {
                this.createdRid = yield xml_helper_1.XmlHelper.getNextRelId(this.targetArchive, this.targetSlideRelFile);
            }
        });
    }
    editTargetHyperlinkRel() {
        return __awaiter(this, void 0, void 0, function* () {
            const targetRelFile = this.targetSlideRelFile;
            const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
            const relationships = relXml.getElementsByTagName('Relationship');
            // Check if the relationship already exists
            let relationshipExists = false;
            for (let i = 0; i < relationships.length; i++) {
                if (relationships[i].getAttribute('Id') === this.createdRid) {
                    this.updateHyperlinkRelation(relationships[i]);
                    relationshipExists = true;
                    break;
                }
            }
            // If the relationship doesn't exist, create it
            if (!relationshipExists) {
                const newRel = relXml.createElement('Relationship');
                newRel.setAttribute('Id', this.createdRid);
                newRel.setAttribute('Type', this.getRelationshipType());
                newRel.setAttribute('Target', this.getRelationshipTarget());
                if (this.hyperlinkType === 'external') {
                    newRel.setAttribute('TargetMode', 'External');
                }
                relXml.documentElement.appendChild(newRel);
                // Track the relationship for content integrity
                content_tracker_1.contentTracker.trackRelation(targetRelFile, {
                    Id: this.createdRid,
                    Target: this.getRelationshipTarget(),
                    Type: this.getRelationshipType(),
                });
            }
            yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
        });
    }
    // Add a method to update the hyperlink in the slide XML
    updateHyperlinkInSlide() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.targetElement) {
                return;
            }
            // Get the slide XML
            const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, this.targetSlideFile);
            // Find all text runs in the element
            const runs = this.targetElement.getElementsByTagName('a:r');
            for (let i = 0; i < runs.length; i++) {
                const run = runs[i];
                const rPr = run.getElementsByTagName('a:rPr')[0];
                if (rPr) {
                    // Find hyperlink elements
                    const hlinkClicks = rPr.getElementsByTagName('a:hlinkClick');
                    for (let j = 0; j < hlinkClicks.length; j++) {
                        const hlinkClick = hlinkClicks[j];
                        // Update the r:id attribute to use the created relationship ID
                        hlinkClick.setAttribute('r:id', this.createdRid);
                        // Ensure the xmlns:r attribute is set
                        hlinkClick.setAttribute('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
                    }
                }
            }
            // Write the updated XML back to the archive
            yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, this.targetSlideFile, slideXml);
        });
    }
    updateHyperlinkRelation(element) {
        element.setAttribute('Type', this.getRelationshipType());
        element.setAttribute('Target', this.getRelationshipTarget());
        if (this.hyperlinkType === 'external') {
            element.setAttribute('TargetMode', 'External');
        }
        else if (element.hasAttribute('TargetMode')) {
            element.removeAttribute('TargetMode');
        }
        content_tracker_1.contentTracker.trackRelation(this.targetSlideRelFile, {
            Id: element.getAttribute('Id') || '',
            Target: this.getRelationshipTarget(),
            Type: this.getRelationshipType(),
        });
    }
    getRelationshipType() {
        return 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';
    }
    getRelationshipTarget() {
        if (this.hyperlinkType === 'internal') {
            // For internal links, the target is a slide ID
            return this.hyperlinkTarget || `slide${this.targetSlideNumber}.xml`;
        }
        else {
            // For external links, the target is a URL
            return this.hyperlinkTarget || 'https://example.com';
        }
    }
    removeFromSlideRels() {
        return __awaiter(this, void 0, void 0, function* () {
            const targetRelFile = this.targetSlideRelFile;
            const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
            const relationships = relXml.getElementsByTagName('Relationship');
            for (let i = 0; i < relationships.length; i++) {
                if (relationships[i].getAttribute('Id') === this.createdRid) {
                    relXml.documentElement.removeChild(relationships[i]);
                    break;
                }
            }
            yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
        });
    }
    static getAllOnSlide(archive, relsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const hyperlinkType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';
            return xml_helper_1.XmlHelper.getRelationshipItems(archive, relsPath, (element, rels) => {
                const type = element.getAttribute('Type');
                if (type === hyperlinkType) {
                    rels.push({
                        rId: element.getAttribute('Id'),
                        type: element.getAttribute('Type'),
                        file: element.getAttribute('Target'),
                        filename: element.getAttribute('Target'),
                        element: element,
                        isExternal: element.getAttribute('TargetMode') === 'External',
                    });
                }
            });
        });
    }
    modifyOnAddedSlide(targetTemplate, targetSlideNumber, hyperlinks) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare(targetTemplate, targetSlideNumber, hyperlinks);
            // Ensure we're using the correct hyperlink target and type
            // This is important for preserving the original hyperlink when copying slides
            if (this.target && this.target.file) {
                this.hyperlinkTarget = this.target.file;
                this.hyperlinkType = this.target.isExternal ? 'external' : 'internal';
            }
            // Update the relationship in the slide's relationships file
            const targetRelFile = this.targetSlideRelFile;
            const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(this.targetArchive, targetRelFile);
            // Find the relationship with the source rId
            const relationships = relXml.getElementsByTagName('Relationship');
            let relationshipUpdated = false;
            for (let i = 0; i < relationships.length; i++) {
                const relationship = relationships[i];
                if (relationship.getAttribute('Id') === this.sourceRid) {
                    // Update the existing relationship
                    relationship.setAttribute('Id', this.createdRid);
                    relationship.setAttribute('Target', this.getRelationshipTarget());
                    relationship.setAttribute('Type', this.getRelationshipType());
                    if (this.hyperlinkType === 'external') {
                        relationship.setAttribute('TargetMode', 'External');
                    }
                    else if (relationship.hasAttribute('TargetMode')) {
                        relationship.removeAttribute('TargetMode');
                    }
                    relationshipUpdated = true;
                    break;
                }
            }
            // If the relationship wasn't found, create a new one
            if (!relationshipUpdated) {
                const newRel = relXml.createElement('Relationship');
                newRel.setAttribute('Id', this.createdRid);
                newRel.setAttribute('Type', this.getRelationshipType());
                newRel.setAttribute('Target', this.getRelationshipTarget());
                if (this.hyperlinkType === 'external') {
                    newRel.setAttribute('TargetMode', 'External');
                }
                relXml.documentElement.appendChild(newRel);
            }
            // Write the updated XML back to the archive
            yield xml_helper_1.XmlHelper.writeXmlToArchive(this.targetArchive, targetRelFile, relXml);
            // Track the relationship for content integrity
            content_tracker_1.contentTracker.trackRelation(targetRelFile, {
                Id: this.createdRid,
                Target: this.getRelationshipTarget(),
                Type: this.getRelationshipType(),
            });
            // Now update the hyperlink reference in the slide XML
            yield this.updateHyperlinkInSlide();
        });
    }
    // Helper method to create a hyperlink in a shape
    static addHyperlinkToShape(archive, slidePath, slideRelsPath, shapeId, hyperlinkTarget, isExternal = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const slideXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, slidePath);
            // Find the shape by ID or name
            const shape = xml_helper_1.XmlHelper.isElementCreationId(shapeId)
                ? xml_helper_1.XmlHelper.findByCreationId(slideXml, shapeId)
                : xml_helper_1.XmlHelper.findByName(slideXml, shapeId);
            if (!shape) {
                throw new Error(`Shape with ID/name "${shapeId}" not found`);
            }
            // Create a new relationship ID
            const relId = yield xml_helper_1.XmlHelper.getNextRelId(archive, slideRelsPath);
            // Add the hyperlink relationship to the slide relationships
            const relXml = yield xml_helper_1.XmlHelper.getXmlFromArchive(archive, slideRelsPath);
            const newRel = relXml.createElement('Relationship');
            newRel.setAttribute('Id', relId);
            newRel.setAttribute('Type', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink');
            newRel.setAttribute('Target', hyperlinkTarget);
            if (isExternal) {
                newRel.setAttribute('TargetMode', 'External');
            }
            relXml.documentElement.appendChild(newRel);
            yield xml_helper_1.XmlHelper.writeXmlToArchive(archive, slideRelsPath, relXml);
            // Add the hyperlink to the shape
            const txBody = shape.getElementsByTagName('p:txBody')[0];
            if (txBody) {
                const paragraphs = txBody.getElementsByTagName('a:p');
                for (let i = 0; i < paragraphs.length; i++) {
                    const paragraph = paragraphs[i];
                    const runs = paragraph.getElementsByTagName('a:r');
                    if (runs.length > 0) {
                        // Add hyperlink to each run or just the first one
                        const run = runs[0];
                        const rPr = run.getElementsByTagName('a:rPr')[0];
                        if (rPr) {
                            // Check if hyperlink already exists
                            let hlinkClick = rPr.getElementsByTagName('a:hlinkClick')[0];
                            if (!hlinkClick) {
                                // Create new hyperlink
                                hlinkClick = slideXml.createElement('a:hlinkClick');
                                rPr.appendChild(hlinkClick);
                            }
                            hlinkClick.setAttribute('r:id', relId);
                            hlinkClick.setAttribute('xmlns:r', 'http://schemas.openxmlformats.org/officeDocument/2006/relationships');
                        }
                    }
                }
            }
            yield xml_helper_1.XmlHelper.writeXmlToArchive(archive, slidePath, slideXml);
            return relId;
        });
    }
}
exports.Hyperlink = Hyperlink;
//# sourceMappingURL=hyperlink.js.map